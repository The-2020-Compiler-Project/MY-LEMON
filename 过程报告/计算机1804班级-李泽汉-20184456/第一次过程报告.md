# 编译原理课程设计—第一次过程报告

> 李泽汉 计算机1804 20184456				
>
> 写于2020.7.3	22：30

## 1. 任务分工与计划统筹

### 1.1.  任务分配

在任务开始初期讨论了整个编译原理课程设计的思路与流程，并根据每位同学的个人能力、具体情况和个人意愿分配了相应工作，并在做课程设计的过程中调整了工作细节，目前暂定的工作分配如下：

**李泽汉**：任务统筹、活跃信息填写、目标代码生成

**苏奇焱**：程序块划分、中间代码优化处理

**吕一鸣**：词法分析器、符号表结构设计实现

**蒋明江**：语法分析器设计实现、中间代码生成设计实现

**吴鹏清**：语法分析器设计实现、中间代码生成设计实现

### 1.2. 文法定义

定义了一个含C语言基础语法的文法，包括变量声明语句、数组声明语句、赋值语句、算术运算表达式、逻辑运算表达式、if语句、while语句、return语句、函数、参数声明、函数调用、函数递归等。

(1)关键字：程序语言定义的具有固定意义的标识符。如：int、float、bool、void、if、else、while、main、return等。

(2)界符：分为单字符界符、双字符界符、程序分隔符等。 单字符界符：+、-、*、/、>、<等

双字符界符：>=、<=、==、!=、||、&&等

程序分隔符：(、)、[、]、{、}、，、；、@等

(3)标识符：用户给变量起的名字，用来标识各种名字，如变量名、数组名、函数名等。

(4)常数：程序中出现以自身形态面对用户和系统的数值，包括整数、小数以及指数。



经过大家反复的讨论与修改错误，最终确定了LL1文法，可以用来写递归下降子程序。

> ## 文法
>
> * 1.开始 -- 程序	后继程序
>
> * 2.后继程序 -- 程序 后继程序| 空
>
> * 3.程序-- **函数定义** **函数声明语句** 复合语句 |  **变量定义** 变量声明
>
> * 4.复合语句 -- {语句列表}
>
> * 5.函数声明 -- 函数类型 （标识符 (参数列表) | main ()）
>
> * 6.变量声明 -- 变量类型 （普通变量声明 后继变量声明 | 数组变量声明 后继数组变量声明）
>
> * 7.普通变量声明 -- 标识符 | 标识符 = 算术表达式 | 标识符 = 字符 | 标识符 = 字符串
>
> * 8.后继变量声明 -- ,普通变量声明 后继变量声明 ;| 空
>
> * 9.数组变量声明 -- 数组名> | 数组赋值语句
>
> * 10.数组名 -- **标识符** [**数字**]
>
> * 11.后继数组变量声明 -- ，数组变量声明 后继数组变量声明;| 空
>
> * 12.数组赋值语句 -- 数组名 = [值列表]
>
> * 13.值列表 -- 整数 后继整数
>
> * 14.后继整数 --，整数 后继整数| 空
>
> * 15.参数列表 -- 参数声明 后继参数声明| 空
>
> * 16.参数声明 -- 类型2 普通变量声明
>
> * 17.后继参数声明 --, 参数声明 后继参数声明| 空
>
> * 18.函数类型 -- int| char | float | double | bool |void   
>
> * 19.变量类型 -- int| char | float | double |bool   
>
> * 20.语句列表 --语句 语句列表|空
>
> * 21.语句 --变量声明 | 赋值语句; | if 条件语句|  while while语句|return  return 语句  
>
> * 22.条件语句 --(逻辑语句)（语句|复合语句 ）|if (逻辑语句)（语句（else（语句|复合语句 ）|空）|<复合语句> （else（语句|复合语句 ）|空）
>
> * 23.while语句 -- (逻辑语句)（语句|复合语句 ）
>
> * 24.逻辑语句 --逻辑项||逻辑语句 |逻辑项
>
> * 25.逻辑项 -- 逻辑因子&&逻辑项|逻辑因子
>
> * 26.逻辑因子 -- 逻辑因子a1逻辑因子2|逻辑因子2
>
> * 27.逻辑因子2 -- 逻辑因子2 a2 算术表达式
>
> * 28.算术表达式 -- 算术表达式 ω0 项 | 项       
>
> * 29.算数项-- 项 ω1  因子 | 因子         
>
> * 30.算数因子 -- 单元> | ω2 单元
>
> * 31.算数单元-- 算术量 | ( 逻辑语句 ） 
>
> * 32.算术量 -- 标识符| 常数 
>
> * 33.return --标识符 |对应常量
>
>   
>
>   #### 标注：
>
>   * ω0 — +或-
>   * ω1 — *或/或%
>   * ω2 — 单目运算符
>   * α1 — ==或!=
>   * α2 — >=或>或<=或<



### 1.3. 接口定义

通过大家共同讨论，最终确定了在工作过程中的一些前后端接口的数据结构，以便能并行完成课设工作。

## 2. 目标代码生成

### 2.1. 活跃信息填写

在优化四元式，需要根据基本块进行活跃信息填写。目的是为目标代码生成提供参考，目标代码生成需要基于活跃信息思想来分配寄存器，并根据寄存器的存储情况来确定是否生成关于寄存器和内存交换信息的目标代码。

因为符号表的接口暂时还没有确定下来，所以活跃信息属性没有加入到符号表中，而是在四元式结构体中添加了活跃信息，这种做法的优点可以在符号表接口没有确定下来的同时并行开始我的目标代码生成的工作，削减了查表的操作，简化了目标代码生成的工作。

#### 2.1.1  数据结构

```c++
struct QtTerm       //四元式
{
    string first;
    bool firstac;
    string second;
    bool secondac;
    string third;
    bool thirdac;
    string fourth;
    bool fourthac;
};
vector<QtTerm>NewQt;       //优化后四元式
struct Active		//变量活跃信息
{
    string qt_name;
    bool qt_ac = 1;
};
```

#### 2.1.2  算法

活跃信息重要用途之一是为基本块进行存储器分配。一个值被计算保存到一个寄存器中后，很有可能在基本块中被使用。如果它在基本块中是死的，就不必在结尾处保存这个值。另外在所有寄存器被占用时，如果还需申请寄存器的话，应该考虑使用一个存储了已死亡的值的寄存器，因为该值无需保存到内存。

一个变量从某时刻(q)起,到下一个定义点止，其间若有应用点，则称该变量在q是活跃的(y),否则称该变量在q是非活跃的(n)。

**1.基于基本块填写活跃信息：**

基本块划分算法：

1.程序中第一个四元式作为第一个基本块的入口。

2.遇到标号四元式，结束当前块，且将该标号四元式作为新基本块入口，上一个为出口。

3.如果遇到跳转四元式，结束当前块作为出口，下一个四元式为新基本块入口。

4.如果遇到赋值四元式且X是换名形参，则结束当前块作为出口，下一个四元式作为新块入口。

**2.初始化活跃信息**：

（1）临时变量在基本块出口后是非活跃的(n)。

（2）非临时变量在基本块出口后是活跃的(y)。

**3.逆序扫描基本块内各四元式：**

如果是结果，则活跃信息变为n；如果不是结果，则活跃信息变为y。

#### 2.1.3 截图

![image-20200702215543040](C:\Users\lizehan\AppData\Roaming\Typora\typora-user-images\image-20200702215543040.png)



### 2.2.目标代码

将经过局部优化后的四元式翻译为8086汇编格式代码，通过查询前端提供的符号表确定作用域。这一部分需要针对每一种四元式进行翻译，在翻译之前，需要考虑寄存器的存储情况，基于活跃信息思想来分配寄存器；并根据寄存器的存储情况来确定是否生成关于寄存器和内存交换信息的目标代码。

本次拟定采用8086汇编语言作为目标代码进行输出，可以更好地检查整个编译系统的效率与正确性，不过由于工作量过于繁重，不知道能不能完成，所以采用虚拟机目标代码作为备用方案。

目前工作：

#### 2.2.1. 数据结构

```c++
struct ObjectCode       //汇编语句
{
    int id;//标号
    string operation;//操作指令
    string dest;//目标操作数
    string source;//源操作数
};

vector<QtTerm>NewQt;		//新四元式储存区
vector<ObjectCode>ob_code;//目标代码存储区
stack<int>Sem;//语义栈
map<string, int> offsetTable;//汇编内存地址
stack<string> ifelseNum;	//ifelse标号栈，用于解决if嵌套的标号问题
int reOpNum = 0;		//逻辑运算符标号
int ifNum = 0;			//ifelse标号

```

#### 2.2.2. 算法

目标代码生成程序的算法大致流程：首先初始化优化后的四元式等必要信息和对接前端符号表以供后续所需，并开辟足够但不至于浪费的数据段、堆栈段空间，定义DI,SI指针用来指向内存空间，通过变址寻址方式获取地址，约定DX,BX分别为目标操作数寄存器和源操作数寄存器，原因是他们用的机会比较少，而且在加入输出之后比较方便，可以直接从BX输出。

目前完成了加减乘除运算，与或非逻辑运算，关系运算符，if-else可嵌套语句等，通过DOSBOX运行后，结果正确。

具体算法伪代码实在是不想写了，因为不确定用不用这个方案，可能最后要大改，所以先不放上来了，思路和课上老师讲的单寄存器目标代码生成思路差不多，只是需要考虑汇编语言的语法特点和内存与寄存器分配问题。

在写if-else的过程中根据汇编语言的特性，因为有标号跳转，所以放弃了回填函数，所以同时也放弃了语义栈。

#### 2.2.3. 测试

源程序：

```c++
void main()
{
int a,b,c,d;
a=21;
if(a>20&&a<24)
{
if(a==21)
{
b=a*2;
}
else
{
b=a*2+1;
}
}
else
{
a=a*2+2;
}
}
```

优化后四元式（接口入口）：

```asm
hanshu	_	_	main	
=	21	_	a	
>	21	20	t0	
<	21	24	t1	
&&	t0	t1	t2	
if	t2	_	_	 	
==	a	21	t3	
if	t3	_	_ 	 	
*	a	2	b	
el	_	_	_ 	 	 	
*	a	2	t5	
+	t5	1	b	
ie	_	_	_ 	 	 	
el	_	_	_ 	 	 	 	 	 	
*	a	2	t7	
+	t7	2	a	
ie	_	_	_ 	 	 	
END	_	_	_	
```

汇编代码生成：

```asm
DSEG	SEGMENT	 	
TEMP	DW	2 DUP(?)	
DATA	DW	100 DUP(?)	
DSEG	ENDS	 	
SSEG	SEGMENT	STACK	
STK	DW	50 DUP(0)	
SSEG	ENDS	 	
CSEG	SEGMENT		
	ASSUME	CS:CSEG,DS:DSEG,SS:SSEG,ES:DSEG	
START:			
MOV	AX,	DSEG	
MOV	DS,	AX	
MOV	ES,	AX	
MOV	AX,	SSEG	
MOV	SS,	AX	
MOV	SP,	SIZE STK	
MOV	DI,	OFFSET DATA	
MOV	SI,	OFFSET TEMP	
MOV	DX,	21	
MOV	[DI+2],	DX	
MOV	[DI+4],	DX	
MOV	DX,	21	
MOV	BX,	20	
CMP	DX,	BX	
JA	ROP0		
MOV	DX,	0	
JMP	ROPCONTI0		
ROP0:			
MOV	DX,	1	
ROPCONTI0:			
MOV	[DI+6],	DX	
MOV	DX,	21	
MOV	BX,	24	
CMP	DX,	BX	
JB	ROP1		
MOV	DX,	0	
JMP	ROPCONTI1		
ROP1:			
MOV	DX,	1	
ROPCONTI1:			
MOV	[DI+8],	DX	
MOV	DX,	[DI+6]	
MOV	BX,	[DI+8]	
AND	DX,	BX	
CMP	DX,	0	
JNE	PD10		
JE	PD00		
PD10:			
MOV	DX,	[DI+2]	
MOV	BX,	21	
CMP	DX,	BX	
JE	ROP2		
MOV	DX,	0	
JMP	ROPCONTI2		
ROP2:			
MOV	DX,	1	
ROPCONTI2:			
CMP	DX,	0	
JNE	PD11		
JE	PD01		
PD11:			
MOV	DX,	[DI+2]	
MOV	BX,	2	
MOV	AX,	DX	
MUL	BX		
MOV	DX,	AX	
MOV	[DI+10],	DX	
JMP	CONTI1	 	
PD01:			
MOV	DX,	[DI+2]	
MOV	BX,	2	
MOV	AX,	DX	
MUL	BX		
MOV	DX,	AX	
MOV	BX,	1	
ADD	DX,	BX	
MOV	[DI+12],	DX	
CONTI1:			
JMP	CONTI0	 	
PD00:			
JMP	CONTI0	 	
PD00:			
MOV	DX,	[DI+2]	
MOV	BX,	2	
MOV	AX,	DX	
MUL	BX		
MOV	DX,	AX	
MOV	BX,	2	
ADD	DX,	BX	
MOV	[DI+14],	DX	
CONTI0:			
MOV	AH,	4CH	
INT	21H		
CSEG	ENDS	 	
	END	START	
```

汇编测试结果：可能看不到图

![image-20200703223345097](C:\Users\lizehan\AppData\Roaming\Typora\typora-user-images\image-20200703223345097.png)

正确输出（输出功能是直接添加的，修改了一下程序）数字ASCLL码对应的字符。

## 3.后续工作

主要就是目标代码生成的后续工作，处理其他的四元式，如while,函数，返回等重要目标代码，并根据前端的工作进展调整代码。计划在第一周内完成汇编语言的生产（基本不可能）。并且其他课设的阶段验收也给我带来了不小的挑战，我将在第一周内尽可能保质保量的完成目标代码生成的工作，也准备了退而求其次的PLAN-B，生成虚拟机代码。