# 编译原理课程设计—第二次过程报告

> 李泽汉 计算机1804 20184456				
>
> 写于2020.7.8	17：30
>
> 接着第一次过程报告写的

## 2.目标代码生成

### 2.2.目标代码

将经过局部优化后的四元式翻译为8086汇编格式代码，通过查询前端提供的符号表确定作用域。这一部分需要针对每一种四元式进行翻译，在翻译之前，需要考虑寄存器的存储情况，基于活跃信息思想来分配寄存器；并根据寄存器的存储情况来确定是否生成关于寄存器和内存交换信息的目标代码。

本次课程设计采用8086汇编语言作为目标代码进行输出，可以更好地检查整个编译系统的效率与正确性。

#### 2.2.1. 数据结构

```c++
struct ObjectCode       //汇编语句
{
	int id;//标号
	string operation;//操作指令
	string dest;//目标操作数
	string source;//源操作数
};

vector<ObjectCode>ob_code;//目标代码存储区
map<string, int> offsetTable;//汇编内存地址
map<string, int> FUNCoffsetTable;//函数汇编内存地址
stack<string> ifelseSTK;    //ifelse标号栈
stack<string> whileSTK;     //while标号栈
stack<string> xingcanSTK;   //形参栈，用来管理形参
stack<string> funcSTK;      //函数名栈，标记当前处理的函数
int SIoffset = -2;

//汇编语句标号
int reOpNum = 0;
int notNum = 0;
int ifNum = 0;
int whileNum = 0;

void CODE(string operation, string dest, string source); //送目标代码到缓存区
bool isNum(string s);        //判断是否都是数字，用于判断是否为变量
void active_info_write(int dstart, int dend);    //活跃信息的填写
void active_info();		//基本块内填写活跃信息
void OUTPUTproc();		//输出十进制无符号数子程序
void load_DX(int rdl, int& DIoffset, int offset);        //储存DX内容到内存
void obcode_DX(string DX, int i, int& DIoffset, int rdl);    //将second送DX
void obcode_DXBX(string DX,int i,int& DIoffset,int rdl); //将second送DX，将third送BX
void Arithmetic_operation(int& i, string& DX, string& BX, int& DIoffset, int& rdl);
//算术运算
void Logical_operation(int& i, string& DX, string& BX, int& DIoffset, int& rdl);  //逻辑运算
void Relational_operation(int& i, string& DX, string& BX, int& DIoffset, int& rdl);  //关系运算符
void objectcode_asm(int dstart, int dend);	//汇编代码生成主函数
void obcode_to_file();		//输出到文件
```

