编译原理第一次报告

1. 我们组整体分工与工作

   ​        我们首先确定要写C语言的编译器，功能包括C语言的变量声明，数组声明，赋值语句，算数运算表达式，逻辑运算表达式，if，while，return，函数，参数声明，函数调用，函数递归等。然后我们根据这些功能，设计了相应的文法，由于我们要用递归下降子程序的语法分析方法，所以，又经过了调整，调整为LL1文法。

   ​        具体分工：

   ​            李泽汉：任务统筹，活跃信息填写，目标代码生成

   ​			苏奇焱：程序块划分，中间代码优化

   ​			吕一鸣：词法分析器，符号表结构设计实现

   ​			蒋明江：语法分析器，中间代码生成

   ​			吴鹏清：语法分析器

2. 我的一周的工作成果

   2.1  基本块划分

   ​        基本块划分算法：

   ​      1.找基本块的入口语句：程序的第一个语句或跳转到的语句，还有紧跟在转向语句后面的语句；

   ​	  2.对于每一个入口语句，构造基本块

   ​		（1）从该入口语句到另一入口语句之间的语句序列；

   ​        （2）从该入口语句到另一转移语句（或停止语句）之间的语句序列；

   2.2   DAG图

   2.2.1  DAG图结点数据结构

   ​		struct DAGnode//DAG图的节点结构体
   ​		{
   ​		string operate;			//运算符
   ​		int ChildLeft = -1;		//左后继
   ​		int ChildRight = -1;	//右后继
   ​		vector<string>SecondMark;//附加标记
   ​		string FirstMark;	//主标记
   ​		string s[4];		//为特殊四元式准备的数组
   ​		};
   ​		vector<DAGnode>DAG;

   ​		用vector保存；

   2.2.2   建DAG图算法

   ​		开始：①DAG置空，依次读取一四元式A=BwC;

   ​					②分别定义B,C结点（若定义过，则免）；

   ​		1.若 赋值四元式 A=B:

   ​				①把A附加于B的附加标记上；

   ​				②若A在n2已定义过，则删去其标记（主标记免删）；

   ​		2.若常值表达式 A=C1wC2 或 A =C1:

   ​				①计算常值C=C1wC2;

   ​				②若C在n1已经定义过，则把A附加在其附加标志上；

   ​					否则申请新结点，且把A附加在其附加标志上；

   ​				③若 A 在 n2 已定义过，则删去其标记（主标记免删）；

   ​		3.若 其他表达式 A=BwC或 A= wB；

    				①若在n1存在公共表达式：BwC 或 wB：

   ​					则把n1附加在n1上；

   ​				 ②如若不存在公共表达式，则申请新结点 n，把A附加上去；

   ​				 ③若 A 在 n2 已定义过，则删去其标记（主标记免删）；

   2.3  通过DAG图，输出优化后的四元式

   ​		输出算法：

   ​			按结点编码顺序，依次读取每一结点：

   ​			（1）若n1为带有附加标记的叶结点： B|A1,A2..

   ​							若 Ai为非临时变量，则生成：q1：Ai=B(i=1,2..)

   ​			（2） 若n1为非叶结点：

   ​							（i）生成q1：A=BwC 或A=wB（A,B,C都是主标记）

   ​							（ii）若带有附加标记，且Ai为非临时变量，则：

   ​										q2：Ai=A  (i=1,2...)

3. 这周工作的问题与经验

   ​    这一周下来，我其实也没遇到什么大问题，主要是前面对接口比较繁琐，对好接口之后，下面的工作就顺畅多了；这也增涨了我的项目开发经验，多个人在开发同一个项目的时候，其实不用等前面的弄完后面在弄，对好接口，就可以并行完成各自的任务，非常的效率；我也通过提交文件学会了使用github，为以后的项目开发打下的基础。

